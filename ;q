import sst 
import os,sys
from optparse import OptionParser

def setup_config_params(configFile):
    l_params = {}
    l_configFile = open(configFile, 'r')
    for l_line in l_configFile:
        l_tokens = l_line.split()
        l_params[l_tokens[0]] = l_tokens[1]
    return l_params

parser = OptionParser(usage="usage: %prog [options]")
parser.add_option("--traceFile",  action='store', dest="TraceFile", help="Name of the trace input file.")
parser.add_option("--traceType",  action='store', dest="TraceType", help="Type of the trace input file.")
parser.add_option("--fileOutput",  action='store', dest="FileOut", help="Location of the output file.")
parser.add_option("--profileAtomics",  action='store', dest="ProfileAtomics", help="Profile atomic instructions")
parser.add_option("--pimSupport",  action='store', dest="PIMSupport", help="Enable PIM support.")
parser.add_option("--waitCycle",  action='store', dest="WaitCycle", help="Follow issue cyles of the trace file.")
parser.add_option("--cramConfig",  action='store', dest="CramConfig", help="CramSim configuration file.")

(options, args) = parser.parse_args()

print int(options.PIMSupport)
if int(options.PIMSupport) == 1:
    config_name = "PIM"
elif int(options.PIMSupport) == 2:
    config_name = "PIM++"
elif int(options.PIMSupport) == 3:
    config_name = "Free"
else:
    config_name = "Baseline"

print int(options.WaitCycle)
if int(options.WaitCycle) == 0:
    trace_config = "noWait"
else:   
    trace_config = "Wait"

extension = ""
if options.TraceType == "Binary":
    extension = "-bin.trace"
elif options.TraceType == "CompressedBinary":
    extension = "-gz.trace"
else:
    extension = ".trace"

# setup CramSim
cramsim_config=options.CramConfig+".cfg"
g_params = setup_config_params(cramsim_config)
memCtrlClockCycle = g_params["clockCycle"]
memCtrlClock = g_params["strControllerClockFreq"]
memSize = int(g_params["numChannels"]) * \
            int(g_params["numRanksPerChannel"]) * \
            int(g_params["numBankGroupsPerRank"]) * \
            int(g_params["numBanksPerBankGroup"]) * \
            int(g_params["numRowsPerBank"]) * \
            int(g_params["numColsPerBank"]) * \
            int(g_params["numBytesPerTransaction"])/(1024*1024*1024);
# Define SST core options
sst.setProgramOption("timebase", "50ps")


## Flags
memDebug = 0
memDebugLevel = 0
coherenceProtocol = "MESI"
rplPolicy = "lru"
busLat = "100ps"
cacheFrequency = "4 Ghz"
coreFrequency = "4 Ghz"
debug = 0
controller_verbose = 0
cacheLineSize = 64
#corecount = 4
corecount = 1

compression_en = 0
memcontent_link_en =0
pca_enable = 0
oracle_mode =0
metacache_entries=0
metadata_predictor=0
contentline_num = corecount

pagesize=4096       #B
pagecount = memSize*1024*1024*1024/pagesize

#
## Application Info
os.environ['SIM_DESC'] = 'EIGHT_CORES'
os.environ['OMP_NUM_THREADS'] = str(corecount)

sst_root = os.getenv( "SST_ROOT" )



# MemHierarchy
membus = sst.Component("membus", "memHierarchy.Bus")
membus.addParams({
    "bus_frequency" : cacheFrequency,
    })

memory = sst.Component("memory", "memHierarchy.MemController")
memory.addParams({
    "do_not_back"				: "1",
    "range_start"           : "0",
    "coherence_protocol"    : coherenceProtocol,
    "debug"                 : memDebug,
    "clock"                 : memCtrlClock,
    "backend" : "memHierarchy.cramsim",
    "backend.access_time" : "1 ns",   # Phy latency
    "backend.max_outstanding_requests" : 4096,
    "backend.mem_size" : "%dGiB"%memSize,
    "request_width"         : cacheLineSize
    })



# CramSim
# txn gen --> memHierarchy Bridge
comp_memhBridge = sst.Component("memh_bridge", "CramSim.c_MemhBridge")
comp_memhBridge.addParams(g_params);
comp_memhBridge.addParams({
                    "numTxnPerCycle" : g_params["numChannels"]
                    })

#comp_controller0 = sst.Component("MemController0", "CramSim.c_ControllerPCA")
comp_controller0 = sst.Component("MemController0", "CramSim.c_Controller")
comp_controller0.addParams(g_params)
comp_controller0.addParams({
                "verbose" : controller_verbose,
 #               "compression_en" : 0,
  #              "loopback_en" : 0,
  #              "pca_enable"  : pca_enable,
  #              "oracle_mode" : oracle_mode,
  #              "metadata_predictor" : metadata_predictor,   #0: perfect predictor, 1:metacache, 2:2lv
  #              "metaCache_entries" : metacache_entries,
                "TxnConverter" : "CramSim.c_TxnConverter",
                "AddrMapper" : "CramSim.c_AddressHasher",
                "CmdScheduler" : "CramSim.c_CmdScheduler" ,
                "DeviceController" : "CramSim.c_DeviceController",
   #             "contentline_num" : contentline_num
                })


# memory device
comp_dimm0 = sst.Component("Dimm0", "CramSim.c_Dimm")
comp_dimm0.addParams(g_params)
comp_dimm0.addParams({
    "pca_enable" : pca_enable}
    )



link_dir_cramsim_link = sst.Link("link_dir_cramsim_link")
link_dir_cramsim_link.connect( (memory, "cube_link", memCtrlClockCycle), (comp_memhBridge,"cpuLink", memCtrlClockCycle) )

# memhBridge(=TxnGen) <-> Memory Controller 
memHLink = sst.Link("memHLink_1")
memHLink.connect( (comp_memhBridge, "memLink", g_params["clockCycle"]), (comp_controller0, "txngenLink", g_params["clockCycle"]) )

# Controller <-> Dimm
cmdLink = sst.Link("cmdLink_1")
cmdLink.connect( (comp_controller0, "memLink", g_params["clockCycle"]), (comp_dimm0, "ctrlLink", g_params["clockCycle"]) )




## Prospero

prospero={}
print "Configuring Prospero processor model (" + str(corecount) + " cores)..."
for p in range(0, corecount):
    print "Creating prospero component core " + str(p)
    prospero["prospero" + str(p)] = sst.Component("prospero" + str(p), "prospero.prosperoCPU")
    prospero["prospero" + str(p)].addParams( {
        "clock" : str(coreFrequency),
        "reader" : "prospero.Prospero" + options.TraceType + "TraceReader",
        "readerParams.file" : str(options.TraceFile) + "-0-0"+extension,
        "readerParams.pimsupport" : str(options.PIMSupport),
        "traceformat" : "1",
        "verbose" : debug,
        "max_outstanding" : 64,
        "max_issue_per_cycle" : 4,
        "pagesize" : 4096,
        "pagecount" : 4096,
        "profileatomics" : str(options.ProfileAtomics),
        "pimsupport" : str(options.PIMSupport),
        "waitCycle" : str(options.WaitCycle),
        "cache_line_size" : cacheLineSize,
        "memcontent_link_en"  : memcontent_link_en,
        "cpuid" : p,
        "skip_cycle" : 10000000000
        } )


def genMemHierarchy(cores):

    for core in range (cores):
        l1 = sst.Component("l1cache_%d"%core, "memHierarchy.Cache")
        l1.addParams({
           "cache_frequency"       : cacheFrequency,
           "cache_size"            : "32KB",
           "cache_line_size"       : cacheLineSize,
           "associativity"         : "8",
           "access_latency_cycles" : "4",
           "coherence_protocol"    : coherenceProtocol,
           "replacement_policy"    : rplPolicy,
           "L1"                    : "1",
           "debug"                 : memDebug,  
           "debug_level"           : memDebugLevel, 
           "mshr_num_entries"      : "32",
           "mshr_latency_cycles"   : 2
           })

        l2 = sst.Component("l2cache_%d"%core, "memHierarchy.Cache")
        l2.addParams({
            "cache_frequency"       : cacheFrequency,
            "cache_size"            : "256KB",
            "cache_line_size"       : cacheLineSize,
            "associativity"         : "8",
            "access_latency_cycles" : "8",
            "coherence_protocol"    : coherenceProtocol,
            "replacement_policy"    : rplPolicy,
            "L1"                    : "0",
            "debug"                 : memDebug,  
            "debug_level"           : memDebugLevel, 
            "mshr_num_entries"      : "64",
            "mshr_latency_cycles" : 2
        })

       ## SST Links
       # Prospero -> L1(PRIVATE) -> L2(PRIVATE)  -> L3 (SHARED) -> DRAM 
       #ArielL1Link = sst.Link("cpu_cache_%d"%core)
       #ArielL1Link.connect((ariel, "cache_link_%d"%core, busLat), (l1, "high_network_0", busLat))

        prospero_cache_link = sst.Link("prospero_cache_link_" + str(core))
        prospero_cache_link.connect( ( prospero["prospero" + str(core)], "cache_link", busLat), (l1, "high_network_0", busLat) )

        L1L2Link = sst.Link("l1_l2_%d"%core)
        L1L2Link.connect((l1, "low_network_0", busLat), (l2, "high_network_0", busLat))
        L2MembusLink = sst.Link("l2_membus_%d"%core)
        L2MembusLink.connect((l2, "low_network_0", busLat), (membus, "high_network_%d"%core, busLat))
        
       # MemContentLink = sst.Link("memContent_%d"%core)
       # MemContentLink.connect((prospero["prospero" + str(core)], "linkMemContent",busLat), (comp_controller0, "lane_%d"%core, busLat));


    l3 = sst.Component("L3cache", "memHierarchy.Cache")
    l3.addParams({
        "cache_frequency"       : cacheFrequency,
        "cache_size"            : "4MB",
        "cache_line_size"       : cacheLineSize,
        "associativity"         : "8",
        "access_latency_cycles" : "20",
        "coherence_protocol"    : coherenceProtocol,
        "replacement_policy"    : rplPolicy,
        "L1"                    : "0",
        "debug"                 : memDebug,  
        "debug_level"           : memDebugLevel, 
        "mshr_num_entries"      : "512",
        "mshr_latency_cycles"   : 4
    })
    
    # Bus to L3 and L3 <-> MM
    BusL3Link = sst.Link("bus_L3")
    BusL3Link.connect((membus, "low_network_0", busLat), (l3, "high_network_0", busLat))
    L3MemCtrlLink = sst.Link("L3MemCtrl")
    L3MemCtrlLink.connect((l3, "low_network_0", busLat), (memory, "direct_link", busLat))
    
genMemHierarchy(corecount)        

# Enable SST Statistics Outputs for this simulation
#sst.enableAllStatisticsForAllComponents({"type":"sst.AccumulatorStatistic"})
#sst.setStatisticLoadLevel(7)
#sst.setStatisticOutput("sst.statOutputConsole")


bname = os.path.basename(options.TraceFile)
cname = os.path.basename(options.CramConfig)
print(bname)
print(cname)
print(options.FileOut)
print(config_name)
print(trace_config)
print("memsize:%dGB"%memSize)


#sst.setStatisticOutput("sst.statOutputCSV")
#sst.setStatisticOutputOptions( {
#		"filepath"  : options.FileOut +"/stats-snb-prospero_" + bname + "_" + cname + "_" + config_name + "_" + trace_config + ".csv",
#		"separator" : ","
#    } )


